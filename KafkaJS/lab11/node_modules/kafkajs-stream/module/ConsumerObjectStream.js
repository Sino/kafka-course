import { Readable } from "stream";
export class ConsumerObjectStream extends Readable {
    constructor(kafka, options) {
        super({ objectMode: true, highWaterMark: options.highWaterMark ?? 512 });
        this.onCrash = async (err) => {
            console.error(err);
            this.init();
            await this.start();
        };
        this.kafka = kafka;
        this.options = options;
        this.init();
    }
    init() {
        this.connected = false;
        this.started = false;
        this.paused = false;
    }
    _read() {
        (async () => {
            try {
                await this.start();
            }
            catch (e) {
                this.destroy(e);
            }
        })();
    }
    async start() {
        if (!this.connected) {
            this.connected = true;
            this.consumer = this.kafka.consumer(this.options.config);
            await this.consumer.connect();
            for (const topic of this.options.topics) {
                await this.consumer.subscribe(topic);
            }
            this.consumer.on("consumer.crash", this.onCrash);
        }
        if (!this.started) {
            this.started = true;
            await this.run();
        }
        if (this.paused) {
            this.paused = false;
        }
    }
    async run() {
        await this.consumer.run({
            eachBatchAutoResolve: false,
            eachBatch: async ({ batch, resolveOffset, heartbeat }) => {
                if (this.paused) {
                    return;
                }
                for (const message of batch.messages) {
                    if (this.paused) {
                        break;
                    }
                    const payload = this.options.transform?.(message) ?? message;
                    const continueToPush = this.push(payload);
                    resolveOffset(message.offset);
                    await heartbeat();
                    if (!continueToPush) {
                        this.paused = true;
                    }
                }
            },
        });
    }
    _destroy(error) {
        this.consumer.disconnect();
        super.destroy(error === null ? undefined : error);
    }
}
//# sourceMappingURL=ConsumerObjectStream.js.map